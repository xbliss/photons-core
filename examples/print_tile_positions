#!/usr/bin/python -ci=__import__;o=i("os");s=i("sys");a=s.argv;p=o.path;y=p.join(p.dirname(a[1]),".python");o.execv(y,a)

from photons_app.actions import an_action

from photons_control.script import FromGenerator
from photons_control.colour import make_hsbk
from photons_messages import TileMessages
from photons_canvas import Coords

from collections import defaultdict
import logging
import sys

log = logging.getLogger("positions")


@an_action(needs_target=True, special_reference=True)
async def print_tile_positions(collector, target, reference, **kwargs):
    """
    Print ASCII art of the where your tiles are
    """

    def e(error):
        log.error(error)

    coords = Coords()

    positions = {}
    letters = list("abcdefghijklmnopqrstuvwxyz")

    async def gen(reference, sender, **kwargs):
        plans = sender.make_plans("chain", "capability")

        follower = 0
        async for serial, _, info in sender.gatherer.gather_per_serial(plans, reference, **kwargs):
            if not info["capability"]["cap"].has_chain:
                continue

            chain = info["chain"]["chain"]
            coords.add_device(serial, chain)

            for tile_index, item in enumerate(chain):
                positions[(serial, tile_index)] = (
                    letters.pop(0),
                    (serial, tile_index, item.user_x, item.user_y),
                )

                yield TileMessages.Set64(
                    target=serial,
                    tile_index=tile_index,
                    x=0,
                    y=0,
                    length=1,
                    width=item.width,
                    colors=[
                        make_hsbk("red brightness:0.1"),
                        make_hsbk("brightness:0"),
                        make_hsbk("brightness:0"),
                    ]
                    * follower,
                    res_required=False,
                )
                follower += 1

    await target.send(FromGenerator(gen), reference, error_catcher=e)

    by_point = {}
    for device_coords in coords.by_device.values():
        for coord in device_coords:
            for point in coord.points:
                by_point[point] = positions[(coord.serial, coord.chain_index)]

    by_row = defaultdict(list)
    for (col, row) in coords.all_points:
        by_row[row].append(col)

    (left_x, right_x), (top_y, bottom_y), _ = coords.bounds

    for row in range(bottom_y, top_y):
        if row not in by_row:
            by_row[row] = []

    skip = {}
    for row, cols in reversed(sorted(by_row.items())):
        if cols:
            for col in range(left_x, right_x):
                if col in cols:
                    ch, (s, t, x, y) = by_point[(col, row)]
                    if (s, t) not in skip:
                        ps = f"{str(x):6s},{str(y):6s}"
                        skip[(s, t)] = (row - 4, ps)

                    r, ps = skip[(s, t)]
                    if row == r:
                        if ps:
                            sys.stdout.write(f"{ch}{ps}{ch} ")
                            skip[(s, t)] = (r, "")
                    else:
                        sys.stdout.write(f"{ch} ")

                else:
                    sys.stdout.write("  ")
        sys.stdout.write("\n")


if __name__ == "__main__":
    __import__("photons_core").run("lan:print_tile_positions {@:1:}")
